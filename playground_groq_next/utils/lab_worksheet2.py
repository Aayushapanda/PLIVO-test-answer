# -*- coding: utf-8 -*-
"""Lab Worksheet2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WJfGUqm1TXCgiSSFuuzoGCNlrXOTappi

Problem 1:
range()= returns an iterable list from 0 to n-1

enumerate() adds an index to an iterable and makes an object from this.

zip combines iterables into a tuple

any() if there is at least one true

all() if all are true

chr() int -> char

ord() char-> int [ascii]

map excecutes a function over the entire iterable

filter() gets the values that pass a given condition from an iterable

str.join joins 2 trings together

Problem 1
"""

a= int(input("Enter a"))
b= int(input("Enter b"))
print(int(a*a+b*b))

"""Problem 2"""

a= int(input("Enter a"))
b= int(input("Enter b"))
x=int(0)
for i in range(a,b+1):
    if i%2==1:
        x+=i
print (x)

"""Problem 3"""

def dotp(a,b):
  c=[]
  sum=int(0)
  if len(a)!=len(b):
    print("Error")
    return([])
  else:
    for i in range(len(a)):
      c.append(a[i]*b[i])
    for j in range(len(c)):
      sum +=float(c[j])
    return sum
print(dotp([1,2,3],[6,7,9]))

def outp(a,b):
  c=[]
  if len(a)!=len(b):
    print("Error")
    return([])
  else:
    for i in range(len(a)):
      d=[]
      for j in range(len(b)):
        d.append(a[i]*b[j])
      c+=[d]
    return c
print(outp([1,2,3],[6,7,9]))

def multiply(A, B):
    rows_A = len(A)
    cols_A = len(A[0])
    rows_B = len(B)
    cols_B = len(B[0])

    # Check if via raising an error instead of printing it
    if cols_A != rows_B:
        raise ValueError("The number of columns in the first matrix must be equal to the number of rows in the second matrix.")
    result_matrix = [[0 for _ in range(cols_B)] for _ in range(rows_A)]


    for i in range(rows_A):
        for j in range(cols_B):
            for k in range(cols_A):
                result_matrix[i][j] += A[i][k] * B[k][j]

    return result_matrix

matrixA = [
        [6, 2, 3],
        [4, 5, 6]
    ]
matrixB = [
        [9, 8],
        [9, 10],
        [11, 12]
    ]

result = multiply(matrixA, matrixB)


print("Result of A * B is \n")
for row in result:
  print(row)

def hadamard_prod(A, B):
    # Get dims
    rows_A = len(A)
    cols_A = len(A[0])
    rows_B = len(B)
    cols_B = len(B[0])

    # if the matrices are compatible
    if rows_A != rows_B or cols_A != cols_B:
        raise ValueError("Matrices must have the same dimensions for the Hadamard product.")


    result_matrix = [[0 for _ in range(cols_A)] for _ in range(rows_A)]

    # Iterate through each element and perform the element-wise multiplication
    for i in range(rows_A):
        for j in range(cols_A):
            result_matrix[i][j] = A[i][j] * B[i][j]

    return result_matrix


matrix_A = [
        [1, 2, 3],
        [4, 5, 6]
    ]

matrix_B = [
        [7, 8, 9],
        [10, 11, 12]
    ]


result = hadamard_prod(matrix_A, matrix_B)


print("Hadamard product (A * B):\n")
for row in result:
  print(row)

"""Problem 4"""

def iitmid(id):
# Write your code here
  if id[0:2].isalpha() and id[2:4].isnumeric() and id[5:8].isnumeric() and id[4].isalpha:
    return True
  else:
    return False
id=str("BS23B015")
print(iitmid(id))

def panid(pan):
  if pan[0:5].isalpha() and pan[5:9].isnumeric() and pan[9].isalpha:
    return True
  else:
    return False
pan_id=str("ASTRO6666M")
print(panid(pan_id))

"""Problem 5"""

def find_k_closest_neighbors(arr, x, k):

    # Handle edge case
    if k <= 0:
        return []
    if k >= len(arr):
        return sorted(arr)
    if x in arr:
        k+=1

    low, high = 0, len(arr) - 1
    closest_index = -1
    min_diff = float('inf')

    while low <= high:
        mid = low + (high - low) // 2


        current_diff = abs(arr[mid] - x)
        if current_diff < min_diff or (current_diff == min_diff and arr[mid] < arr[closest_index]):
            min_diff = current_diff
            closest_index = mid

        if arr[mid] < x:
            low = mid + 1
        else:
            high = mid - 1



    # Init the pointers
    left, right = closest_index, closest_index
    result = []

    # Add the initi
    if k > 0:
        result.append(arr[closest_index])


    k -= 1


    while k > 0:
        left_val = float('inf') if left <= 0 else arr[left - 1]
        right_val = float('inf') if right >= len(arr) - 1 else arr[right + 1]


        if abs(left_val - x) <= abs(right_val - x):

            if left > 0:
                left -= 1
                result.append(arr[left])
            else:

                right += 1
                result.append(arr[right])
        else:

            if right < len(arr) - 1:
                right += 1
                result.append(arr[right])
            else:

                left -= 1
                result.append(arr[left])

        k -= 1

    # The result list is not necessarily sorted by value at this point, so sort it.
    for i in result:
      if i==x:
        result.remove(i)
    result.sort()
    return result

# Example usage:
if __name__ == "__main__":
    sorted_array = [2, 3, 4, 5, 6, 7]
    target_element = 5
    k_neighbors = 3
    #k=a
    closest_neighbors = find_k_closest_neighbors(sorted_array, target_element, k_neighbors)
    print(f" sorted array is: {sorted_array}")
    print(f" target element is: {target_element}")
    print(f" number of neighbors to find (k) is: {k_neighbors}")
    print(f"Thus the {k_neighbors} closest neighbors are: {closest_neighbors}")

"""Problem 6"""

DNA="AATTGGGGGCCCCCAAAAAGGGGGTTTTTTT"
print(f"length is: {len(DNA)}")

def count(st,a):
  j=int (0)
  for i in st.upper():
    if i==a:
      j+=1
    if i not in ['A','T','G','C','U']:
      print("Error Not a nucleotide!!")
      return([])
  return j

def reverse(st):
  st2 =""
  for i in st.upper():

    if i == "A":
      st2+=('T')
    if i == "T":
      st2+=('A')
    if i == "G":
      st2+=('C')
    if i == "C":
      st2+=('G')
    if i not in ['A','T','G','C','U']:
      print("Error Not a nucleotide!!")
  return st2
def transcript(st):
  st2 =""
  for i in st.upper():
    if i == "T":
      st2+=('U')
    if i not in ['A','T','G','C','U']:
      print("Error Not a nucleotide!!")
    if i in ['A','G','C','U']:
      st2+=i
  return st2

print(f"A: {count(DNA,'A')}")
print(f"T: {count(DNA,'T')}")
print(f"G: {count(DNA,'G')}")
print(f"C: {count(DNA,'C')}")
print(f"Replacement complement {reverse(DNA) }")
print(f"Transcript {transcript(DNA) }")